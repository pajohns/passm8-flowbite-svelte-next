<script lang="ts" module>
  import type { Snippet } from "svelte";

  export interface TriggeredToggleEvent extends ToggleEvent {
    trigger: HTMLElement;
  }

  export interface PopperProps extends Omit<HTMLAttributes<HTMLDivElement>, "onbeforetoggle" | "ontoggle"> {
    triggeredBy?: string;
    trigger?: "hover" | "click";
    placement?: Placement;
    arrow?: boolean;
    arrowClass?: string;
    offset?: number;
    yOnly?: boolean; // special case for megamenu - only move on y axis
    strategy?: Strategy;
    reference?: string | undefined;
    middlewares?: Middleware[];
    children: Snippet;

    onbeforetoggle?: (ev: TriggeredToggleEvent) => void;
    ontoggle?: (ev: TriggeredToggleEvent) => void;
  }
</script>

<script lang="ts">
  import type { Coords, Middleware, Placement, Strategy } from "@floating-ui/dom";
  import * as dom from "@floating-ui/dom";
  import type { HTMLAttributes } from "svelte/elements";
  import Arrow from "./Arrow.svelte";

  const TRIGGER_DELAY = 200;

  let { triggeredBy, trigger = "click", placement = "top", offset = 8, arrow = false, yOnly = false, strategy = "absolute", reference, middlewares = [dom.flip(), dom.shift()], onbeforetoggle: _onbeforetoggle, ontoggle: _ontoggle, class: className = "", arrowClass = "", children }: PopperProps = $props();

  let focusable: boolean = true;
  let clickable: boolean = $derived(trigger === "click");
  let hoverable: boolean = $derived(trigger === "hover");

  let popover: HTMLElement | null = null;
  let invoker: HTMLButtonElement | null = null;
  let referenceElement: HTMLElement | null = null;
  let triggerEls: HTMLButtonElement[] = [];
  let arrowParams: { placement: Placement; cords: Partial<Coords>; strategy: "absolute" | "fixed" } = $state({
    placement,
    cords: { x: 0, y: 0 },
    strategy
  });

  const px = (n: number | undefined) => (n ? `${n}px` : "");

  function updatePopoverPosition() {
    if (!invoker || !popover) {
      return;
    }

    const arrowEl: HTMLElement | null = popover.querySelector(".popover-arrow");

    let middleware: Middleware[] = [...middlewares, dom.offset(offset)];
    if (arrowEl) middleware.push(dom.arrow({ element: arrowEl }));

    return dom.computePosition(referenceElement ?? invoker, popover, { placement, middleware, strategy }).then(({ x, y, middlewareData: { arrow }, placement: pl, strategy }) => {
      if (popover) {
        Object.assign(popover.style, { position: strategy, left: yOnly ? "0" : px(x), top: px(y) });

        if (arrow && arrowEl) {
          arrowParams = { placement: pl, cords: { x: arrow.x, y: arrow.y }, strategy };
        }
      }
    });
  }

  let isTriggered: boolean = false;

  async function open_popover(ev: Event) {
    // throttle
    isTriggered = true;
    await new Promise((resolve) => setTimeout(resolve, TRIGGER_DELAY));
    if (!isTriggered) return;

    ev.preventDefault();

    if (ev.target !== invoker && triggerEls.includes(ev.target as HTMLButtonElement)) {
      invoker = ev.target as HTMLButtonElement;
      // if (invoker) invoker.popoverTargetElement = popover;
      popover?.hidePopover(); // invoker changed need to hide old popover
    }

    if (ev.type === "mousedown") popover?.togglePopover();
    else popover?.showPopover();
  }

  async function close_popover(ev: Event) {
    isTriggered = false;
    await new Promise((resolve) => setTimeout(resolve, TRIGGER_DELAY));
    if (isTriggered) return;

    // if popover has focus don't close when leaving the invoker
    if (ev?.type === "mouseleave" && popover?.contains(popover.ownerDocument.activeElement)) return;
    if (ev?.type === "focusout" && popover?.contains(popover.ownerDocument.activeElement)) return;

    popover?.hidePopover();
  }

  let autoUpdateDestroy = () => {};

  function on_before_toggle(ev: ToggleEvent) {
    if (!invoker || !popover) return;

    (ev as TriggeredToggleEvent).trigger = invoker;
    _onbeforetoggle?.(ev as TriggeredToggleEvent);

    // Floating UI instance when itâ€™s closed we need to keep a autoUpdate destroy function

    if (ev.newState === "open") {
      autoUpdateDestroy = dom.autoUpdate(referenceElement ?? invoker, popover, updatePopoverPosition);
      popover.ownerDocument.addEventListener("click", closeOnClickOutside);
    } else {
      // When closing the popover, we destroy the autoUpdate instance
      autoUpdateDestroy();
      popover.ownerDocument.removeEventListener("click", closeOnClickOutside);
    }
  }

  function on_toggle(ev: ToggleEvent) {
    if (!invoker) return;

    (ev as TriggeredToggleEvent).trigger = invoker;
    _ontoggle?.(ev as TriggeredToggleEvent);
  }

  function set_triggers(node: HTMLElement) {
    const events: [string, any, boolean][] = [
      ["focusin", open_popover, focusable],
      ["focusout", close_popover, focusable],
      ["mousedown", open_popover, clickable],
      ["mouseenter", open_popover, hoverable],
      ["mouseleave", close_popover, hoverable]
    ];

    if (triggeredBy) triggerEls = [...node.ownerDocument.querySelectorAll<HTMLButtonElement>(triggeredBy)];
    else if (node.previousElementSibling) triggerEls = [node.previousElementSibling as HTMLButtonElement];

    if (!triggerEls.length) {
      console.error("No triggers found.", triggeredBy);
      return;
    }

    if (reference) referenceElement = node.ownerDocument.querySelector<HTMLElement>(reference);
    invoker = triggerEls[0];

    triggerEls.forEach((element: HTMLButtonElement) => {
      // Only force focusable if tooltip is triggered by focus
      if (trigger.includes('focus') && element.tabIndex < 0) {
        element.tabIndex = 0;
      }
      for (const [name, handler, cond] of events) if (cond) element.addEventListener(name, handler);
    });

    $effect(() => {
      return () => {
        triggerEls.forEach((element: HTMLElement) => {
          for (const [name, handler, cond] of events) if (cond) element.removeEventListener(name, handler);
        });
      };
    });
  }

  /**
   * Close the popper when clicking outside of it.
   * This is necessary to get around a bug in Safari where clicking outside of the open popper does not close it.
   */
  function closeOnClickOutside(event: MouseEvent) {
    if (popover && !event.composedPath().includes(popover) && !triggerEls.some((el) => event.composedPath().includes(el))) {
      close_popover(event);
    }
  }
</script>

<div popover="manual" role="tooltip" bind:this={popover} use:set_triggers class:overflow-visible={true} onfocusout={close_popover} onmouseleave={hoverable ? close_popover : undefined} onmouseenter={hoverable ? open_popover : undefined} onbeforetoggle={on_before_toggle} ontoggle={on_toggle} class={className}>
  {@render children()}
  {#if arrow}
    <Arrow {...arrowParams} class={arrowClass} />
  {/if}
</div>

<!--
@component
[Go to docs](https://flowbite-svelte-next.com/)
## Props
@props: triggeredBy: any;
@props:trigger: any = "click";
@props:placement: any = "top";
@props:offset: any = 8;
@props:arrow: any = false;
@props:yOnly: any = false;
@props:strategy: any = "absolute";
@props:reference: any;
@props:middlewares: any = [dom.flip();
@props:dom.shift()]: any;
@props:onbeforetoggle: any;
@props:ontoggle: any;
@props:class: string = "";
@props:arrowClass: any = "";
@props:children: any;
-->
